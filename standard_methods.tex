\section{csvimport}




\clearpage
\section{dataset\_type}

A dataset imported with \texttt{csvimport} may be typed using
\texttt{dataset\_type}.  This method parses the input data...
An example invocation is the following

\begin{python}
urd.build('dataset_type', ...,
  options=dict(
    column2type=dict(
      auct_start_dt='datetime:%Y-%m-%d',
      brand='json',
      item_id='number',
      comp='unicode:utf-8',
    ),
  )
\end{python}


\subsection{typing}
This section describes all typing options in detail.

\subsubsection{Float Point Numbers}
Floating point numbers may be stored as 32 or 64 bits.  There are six parsing options

\begin{tabular}{lll}
\texttt{float32} & \texttt{float64} & default\\
\texttt{float32i} & \texttt{float64i} & ``ignore'', will discard trailing garbage, such as xxx\\
\texttt{float32e} & \texttt{float64e} & ``exact'', error if parsed number does not fit in type \\
\texttt{float32s} & \texttt{float64s} & ``saturate'', saturate to min/max if number does not fit in type \\
\texttt{float32ei} & \texttt{float64ei} & ``exact'' + ``ignore'' \\
\texttt{float32si} & \texttt{float64si} & ``saturate'' + ``ignore'' \\
\end{tabular}

\subsubsection{Integers}
Integers are stored as either 32 or 64 bits.  Parsing works for several bases...

\begin{tabular}{lll}
  \texttt{int32\_0}   & \texttt{int64\_0}   & ``auto'', avoid and use a deteministic type if possible \\
  \texttt{int32\_0i}  & \texttt{int64\_0i}  & same, ignore trailing garbage \\
  \texttt{int32\_8}   & \texttt{int64\_8}   & ``octal'' \\
  \texttt{int32\_8i}  & \texttt{int64\_8i}  & same, ignore trailing garbage \\
  \texttt{int32\_10}  & \texttt{int64\_10}  & ``decimal'' \\
  \texttt{int32\_10i} & \texttt{int64\_10i} & same, ignore trailing garbage \\
  \texttt{int32\_16}  & \texttt{int64\_16}  & ``hexadecimal'' \\
  \texttt{int32\_16i} & \texttt{int64\_16i} & same, ignore trailing garbage \\
\end{tabular}

There are also a parsing options for integers that are represented in a floating
point format in the source data.



\begin{python}
float32
float64
\end{python}
\\
ignore trailing garbage
\\
\begin{python}
float32i
float64i
\end{python}
\\
floatints are integers, i.e.\ int(float(value)), used for dedotting...
\\
\begin{python}
# e = exact, error on saturate which is int32 when 32 or float64 when 64.
'floatint64e'  
'floatint32e'  
\end{python}

\begin{python}
# s = saturate
'floatint64s'  
'floatint32s'  
\end{python}

\begin{python}
# exact and ignore
'floatint64ei' 
'floatint32ei' 
\end{python}

\begin{python}
# saturate and ignore
'floatint64si' 
'floatint32si' 
\end{python}

specify base, i.e.\ arg to strtol(...,x)
\\
\begin{python}
#_0 == auto (avoid)
    'int64_0'      
    'int32_0'      
# octal
    'int64_8'      
    'int32_8'      
# decimal
    'int64_10'     
    'int32_10'     
# hexadecimal
    'int64_16'     
    'int32_16'     
\end{python}

and with ignore
\\
\begin{python}
    'int64_0i'     
    'int32_0i'     
    'int64_8i'     
    'int32_8i'     
    'int64_10i'    
    'int32_10i'    
    'int64_16i'    
    'int32_16i'    
\end{python}

\begin{python}
'strbool'
# false if in ("false, "0", "f", "no", "off", "nil", "null", "")
# true  otherwise
\end{python}

\begin{python}
#true if float has bits set to one
'floatbool'
# with ignore
'floatbooli'   
\end{python}

time and date
\\
\begin{python}
# strptime-compat format
    'datetime:*'   
    'date:*'       
    'time:*'       
    'datetimei:*'  
    'datei:*'      
    'timei:*'      
\end{python}

strings and byte sequences
\\
\begin{python}
# out from csvimport, lists of bytes
'bytes'
# with strip of characters 8-13,32 from start and end
'bytesstrip'
\end{python}

\begin{python}
# python type "unicode"
'unicode:*'    
# with strip
'unicodestrip:*
# args are
#   strict
#   replace
#   ignore
\end{python}
%python-typen unicode
%strict, replace, ignore (dataset_typing:376)
%strict:   ger error
%replace:  
%ignore:   radera d책liga tecken

\begin{python}
# sequence of letters, 7-bit representation
    'ascii'        
    'asciistrip'   
# with argument
    'ascii:*'      
    'asciistrip:*' 
# replace, strict, encode
# encode 채r reversibel (originalstr채ng kan man f책 tillbaka)
\end{python}

\begin{python}
# number is int or float
    'number'       
# number:int is int, but "37.0" is okay
    'number:int'  se dataset_typing.py:388
\end{python}




\section{csvimport}




\clearpage
\section{dataset\_type}

A dataset imported with \texttt{csvimport} may be typed using
\texttt{dataset\_type}.  This method parses the input data...
An example invocation is the following

\begin{python}
urd.build('dataset_type', ...,
  options=dict(
    column2type=dict(
      auct_start_dt='datetime:%Y-%m-%d',
      brand='json',
      item_id='number',
      comp='unicode:utf-8',
    ),
  )
\end{python}


\subsection{typing}
This section describes all typing options in detail.

\subsubsection{Float Point Numbers}
Floating point numbers may be stored as 32 or 64 bits.  In addition,
there are six parsing options that are useful in different scenarios.
The \emph{ignore} option ignores any trailing characters after the
number.  Then there are \emph{exact} that causes error if the number
does not fit, and \emph{saturate} that silently saturates a
non-fitting number.  These can also be used in combination, see table
below for all alternatives\\

\begin{tabular}{lll}
\texttt{float32} & \texttt{float64} & \emph{default}\\
\texttt{float32i} & \texttt{float64i} & \emph{ignore}, will discard trailing garbage\\
\texttt{float32e} & \texttt{float64e} & \emph{exact}, error if parsed number does not fit in type \\
\texttt{float32s} & \texttt{float64s} & \emph{saturate}, saturate to min/max if number does not fit in type \\
\texttt{float32ei} & \texttt{float64ei} & \emph{exact} + \emph{ignore} \\
\texttt{float32si} & \texttt{float64si} & \emph{saturate} + \emph{ignore} \\
\end{tabular}

\subsubsection{Integers}
Integers are stored as either 32 or 64 bits.  Parsing takes base into
account, so in addition to decimal numbers, it is also straightforward
to parse octal and hexadecimal numbers.  The \emph{ignore} option
causes parsing to ignore trailing garbage characters.\\

\begin{tabular}{lll}
  \texttt{int32\_0}   & \texttt{int64\_0}   & \emph{auto}, avoid and use a deteministic type if possible \\
  \texttt{int32\_0i}  & \texttt{int64\_0i}  & \emph{auto}, ignore trailing garbage \\
  \texttt{int32\_8}   & \texttt{int64\_8}   & \emph{octal} \\
  \texttt{int32\_8i}  & \texttt{int64\_8i}  & \emph{octal}, ignore trailing garbage \\
  \texttt{int32\_10}  & \texttt{int64\_10}  & \emph{decimal} \\
  \texttt{int32\_10i} & \texttt{int64\_10i} & \emph{decimal}, ignore trailing garbage \\
  \texttt{int32\_16}  & \texttt{int64\_16}  & \emph{hexadecimal} \\
  \texttt{int32\_16i} & \texttt{int64\_16i} & \emph{hexadecimal}, ignore trailing garbage \\
\end{tabular}



\subsection{Integers Stored as Floats}

There are also a parsing options for integers that are represented in
a floating point format in the source data.  This is useful if integer
data is stored with decimals, such as \texttt{5.0}.  In pseudocode,
the parsing basically runs \texttt{int(float(value))} for each such
value.\\

\begin{tabular}{lll}
  \texttt{floatint32e} & \texttt{floatint64e}  & \\
  \texttt{floatint32s} & \texttt{floatint64s}  & \\
  \texttt{floatint32ei}& \texttt{floatint64ei} & \\
  \texttt{floatint32si}& \texttt{floatint64si} & \\
\end{tabular}


\begin{python}
'strbool'
# false if in ("false, "0", "f", "no", "off", "nil", "null", "")
# true  otherwise
\end{python}

\begin{python}
#true if float has bits set to one
'floatbool'
# with ignore
'floatbooli'   
\end{python}

time and date
\\
\begin{python}
# strptime-compat format
    'datetime:*'   
    'date:*'       
    'time:*'       
    'datetimei:*'  
    'datei:*'      
    'timei:*'      
\end{python}

strings and byte sequences
\\
\begin{python}
# out from csvimport, lists of bytes
'bytes'
# with strip of characters 8-13,32 from start and end
'bytesstrip'
\end{python}

\begin{python}
# python type "unicode"
'unicode:*'    
# with strip
'unicodestrip:*
# args are
#   strict
#   replace
#   ignore
\end{python}
%python-typen unicode
%strict, replace, ignore (dataset_typing:376)
%strict:   ger error
%replace:  
%ignore:   radera d책liga tecken

\begin{python}
# sequence of letters, 7-bit representation
    'ascii'        
    'asciistrip'   
# with argument
    'ascii:*'      
    'asciistrip:*' 
# replace, strict, encode
# encode 채r reversibel (originalstr채ng kan man f책 tillbaka)
\end{python}

\begin{python}
# number is int or float
    'number'       
# number:int is int, but "37.0" is okay
    'number:int'  se dataset_typing.py:388
\end{python}




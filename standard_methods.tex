\section{csvimport}




\clearpage
\section{dataset\_type}

A dataset imported with \texttt{csvimport} may be typed using
\texttt{dataset\_type}.  This method parses the input data...
An example invocation is the following

\begin{python}
urd.build('dataset_type', ...,
  options=dict(
    column2type=dict(
      auct_start_dt='datetime:%Y-%m-%d',
      brand='json',
      item_id='number',
      comp='unicode:utf-8',
    ),
  )
\end{python}


\subsection{Arguments}


\subsection{Typing}
This section describes all typing options in detail.

\subsubsection{Numbers}
The \emph{number} type is int or float.

\begin{tabular}{ll}
  \texttt{number}     & \texttt{int} or \texttt{float}\\
  \texttt{number:int} & \texttt{int}, converts floats to int.\\
\end{tabular}



\subsubsection{Float Point Numbers}
Floating point numbers may be stored as 32 or 64 bits.  In addition,
there are six parsing options that are useful in different scenarios.
The \emph{ignore} option ignores any trailing characters after the
number.  Then there are \emph{exact} that causes error if the number
does not fit, and \emph{saturate} that silently saturates a
non-fitting number.  These can also be used in combination, see table
below for all alternatives\\

\begin{tabular}{lll}
\texttt{float32} & \texttt{float64} & \emph{default}\\
\texttt{float32i} & \texttt{float64i} & \emph{ignore}, will discard trailing garbage\\
\texttt{float32e} & \texttt{float64e} & \emph{exact}, error if parsed number does not fit in type \\
\texttt{float32s} & \texttt{float64s} & \emph{saturate}, saturate to min/max if number does not fit in type \\
\texttt{float32ei} & \texttt{float64ei} & \emph{exact} + \emph{ignore} \\
\texttt{float32si} & \texttt{float64si} & \emph{saturate} + \emph{ignore} \\
\end{tabular}

\subsubsection{Integers}
Integers are stored as either 32 or 64 bits.  Parsing takes base into
account, so in addition to decimal numbers, it is also straightforward
to parse octal and hexadecimal numbers.  The \emph{ignore} option
causes parsing to ignore trailing garbage characters.\\

\begin{tabular}{lll}
  \texttt{int32\_0}   & \texttt{int64\_0}   & \emph{auto}, avoid and use a deteministic type if possible \\
  \texttt{int32\_0i}  & \texttt{int64\_0i}  & \emph{auto}, ignore trailing garbage \\
  \texttt{int32\_8}   & \texttt{int64\_8}   & \emph{octal} \\
  \texttt{int32\_8i}  & \texttt{int64\_8i}  & \emph{octal}, ignore trailing garbage \\
  \texttt{int32\_10}  & \texttt{int64\_10}  & \emph{decimal} \\
  \texttt{int32\_10i} & \texttt{int64\_10i} & \emph{decimal}, ignore trailing garbage \\
  \texttt{int32\_16}  & \texttt{int64\_16}  & \emph{hexadecimal} \\
  \texttt{int32\_16i} & \texttt{int64\_16i} & \emph{hexadecimal}, ignore trailing garbage \\
\end{tabular}



\subsection{Integers Stored as Floats}

There are also a parsing options for integers that are represented in
a floating point format in the source data.  This is useful if integer
data is stored with decimals, such as \texttt{5.0}.  In pseudocode,
the parsing basically runs \texttt{int(float(value))} for each such
value.\\

\begin{tabular}{lll}
  \texttt{floatint32e} & \texttt{floatint64e}  & \emph{exact}, error if parsed number does not fit in type\\
  \texttt{floatint32s} & \texttt{floatint64s}  & \emph{saturate}, saturate to min/max if number does not fit in type\\
  \texttt{floatint32ei}& \texttt{floatint64ei} & \emph{exact} + \emph{ignore}\\
  \texttt{floatint32si}& \texttt{floatint64si} & \emph{saturate} + \emph{ignore}\\
\end{tabular}



\subsection{Convert to Boolean}
It is common that a column holds values that are to be interpreted as
either \texttt{False} or \texttt{True}.  There are two types that is
useful in this context.  The first one is \texttt{strbool}, that works like this\\

\begin{tabular}{ll}
  \texttt{strbool} & \texttt{False} if value in (\texttt{'false', '0', 'f', 'no', 'off', 'nil', 'null', ''})\\
                   & \texttt{True} otherwise
\end{tabular}
\\
The other is \texttt{floatbool} that is True when the float has bits
set to one and zero otherwise.  There is also a \texttt{floatbooli}
that ignores trailing garbage characters.\\

\begin{tabular}{ll}
  \texttt{floatbool}  & True if float has bits set to one, zero otherwise\\
  \texttt{floatbooli} & same + \emph{ignore}\\
\end{tabular}



\subsection{Time and Date}
There are three types relating to time available, \texttt{date},
\texttt{time}, and \texttt{datetime}.  Each of these has a
corresponding version that ignores trailing garbage characters.
All time types require a format specification as described below\\

\begin{tabular}{ll}
  \texttt{date:*}      & a date with format specifier\\
  \texttt{datei:*}     & same + \emph{ignore}\\
  \texttt{time:*}      & a time with format specifier\\
  \texttt{timei:*}     & same + \emph{ignore}\\
  \texttt{datetime:*}  & a date + time with format specifier\\
  \texttt{datetimei:*} & same + \emph{ignore}\\
\end{tabular}\\

The format is standard Python time formats, see for example\\
\\
\begin{python}
   # will match for example '2017-03-22'
   auct_start_dt='date:%Y-%m-%d'  
   # will match for example '183000', i.e. half past six in the evening
   tod='time:%H%M%S'
   # will match for example '2017-03-22 18:30:15'
   timestamp='datetime:'%Y-%m-%d %H:%M:%S'
\end{python}


\subsection{Strings and Byte Sequences}
There are a number of ways to read string and byte data, depending on
how the raw input data is to be interpreted.  Here are the basic
types, and variations and options will be described below.\\

\begin{tabular}{ll}
  \texttt{bytes}      & list of bytes\\
  \texttt{bytesstrip} & list of bytes, strip characters 8-13,32 from start and end\\
  \texttt{ascii}      & list of ascii characters\\
  \texttt{asciistrip} & list of ascii characters, strip characters 8-13,32 from start and end\\
  \texttt{unicode:*}    & list of unicode characters\\
\end{tabular}\\

\noindent The following also takes argument\\

\begin{tabular}{ll}
  \texttt{unicodestrip:*}  & list of unicode characters, strip characters 8-13,32 from start and end\\
\end{tabular}\\

\noindent where the argument is one of \texttt{replace}, \texttt{ignore}, and \texttt{strict}.
\texttt{strict} will cause error, \texttt{ignore} will erase illegal characters.\\

\begin{tabular}{ll}
  \texttt{ascii:*}      & list of ascii characters\\
  \texttt{asciistrip:*} & list of ascii characters, strip characters 8-13,32 from start and end\\
\end{tabular}\\

\noindent where the argument is one of \texttt{replace}, \texttt{encode}, and \texttt{strict}.
\texttt{strict} will cause error, \texttt{ignore} will erase illegal characters,
and \texttt{encode} is reversible encoding.


\clearpage
\section{dataset\_csvexport}

\clearpage
\section{dataset\_rehash}

\clearpage
\section{dataset\_sort}

\clearpage
\section{dataset\_datesplit, dataset\_datesplit\_discarded}

\clearpage
\section{dataset\_checksum, dataset\_checksum\_chain}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
% Copyright (c) 2018 eBay Inc.                                             %
%                                                                          %
% Licensed under the Apache License, Version 2.0 (the "License");          %
% you may not use this file except in compliance with the License.         %
% You may obtain a copy of the License at                                  %
%                                                                          %
%  http://www.apache.org/licenses/LICENSE-2.0                              %
%                                                                          %
% Unless required by applicable law or agreed to in writing, software      %
% distributed under the License is distributed on an "AS IS" BASIS,        %
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. %
% See the License for the specific language governing permissions and      %
% limitations under the License.                                           %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{chap:urd}

This chapted is the continuation of the chapter~\ref{chap:urd_basic},
``Basic Build Scripting''.  Please read about build script and
joblists before proceeding.


\section{Introduction to Urd}

Build scripts, as presented in chapter~\ref{chap:urd_basic}, provides
a powerful way to build and link jobs.  In may cases, however, this is
not enough.  For example, when a project matures, there is a need for
separation, and if a project uses lots of input files, something is
needed to keep track of them.

Urd is the processing flow controller in the framework.  It is the
primary job dispatcher as well as the bookkeeper of all jobs executed.
It provides a way to look up existing jobs and datasets, and provides
separation in that it eliminates the need to replay build scripts to
find old jobids and datasets.  (It is also an interesting
log-file-based database, that will be further discussed in
section~\ref{xx}.)

Events in urd are separated into what is called \textsl{sessions}.
The core of Urd is a transaction log database storing these sessions
together with meta information.  The result is a server providing
lookups for all jobs executed together with their context.

The Urd database is partitioned into what is called \textsl{lists}.
Lists record sessions and key them using a timestamp.  Lists are
globally readable, but writing requires authentication, so that, for
example, only the production user may publish a model to go live.

With the exception of experimental work and the build script basics
presented in the previous chapter, all work initiated by Urd is run in
closed sessions, with well defined starting and ending points.  The
input parameters to these sessions are recorded as dependencies,
together with the resulting output.



\section{Overview}

Urd sessions exists between the \texttt{urd.begin()}
and \texttt{urd.finish()} functions, like in this short example that
imports a file.

\begin{python}
def main(urd):
    |\colorbox{hl}{urd.begin}|('import/txn', '2018-05-03')
    urd.build('csvimport', options=dict(filename='txn1.txt'))
    |\colorbox{hl}{urd.finish}|('import/txn')
\end{python}

All jobs dispatched between \texttt{begin} and \texttt{finish} will be
appended to the \texttt{import/txn} \textsl{Urd list} with
timestamp \texttt{2018-05-03}.  This also includes meta information,
such as all lookups of jobs done by Urd in the session that will be
appended as dependencies.

The urd-list just created could then be used by other job builds.  For
example, here is a job that does some processing on the imported file
\begin{python}
def main(urd):
    urd.begin(process/test)
        import_session = |\colorbox{hl}{urd.latest}|('import/txn')
        import_timestamp = import_session.timestamp
        import_jobid = import_session.joblist.jobid
        urd.build('process', datasets=dict(source=import_jobid))
    urd.finish('process/test', import_timestamp)
\end{python}
Here, the recently created urd session, \texttt{import/txn}, is
retrieved.  Two things are extracted from this data.  First, the
timestamp of the import session.  The timestamp is used as key for
the \texttt{process/test} session as well, indicating that it is based
on data from the same time instance.  Furthermore, the jobid to
the \texttt{csvimport} job is extracted and fed to
the \texttt{process} job as an input dataset parameter.



\section{Urd Sessions}

There are a number of options associated with a session, as shown
here,
\begin{python}
urd.begin(urdlist, timestamp, caption=None, update=False)
urd.finish(urdlist, timestamp, caption=None)
\end{python}
and the following applies
\begin{itemize}
\item [] \texttt{urdlist} is the name of the Urd list, and the same
  \texttt{urdlist} must be specified in both \texttt{begin}
  and \texttt{finish}.  The \texttt{urdlist} is specified as
  ``\texttt{user/list}'', where the ``\texttt{user/}'' part is
  optional.  The \texttt{user} should correspond to the
  current \texttt{URD\_AUTH} settings, see section~\ref{xxx}.

\item [] \texttt{timestamp} is mandatory, but could be set in either
  \texttt{begin}, \texttt{finish}, or both.  \texttt{finish}
  overrides \texttt{begin}.

\item [] \texttt{caption} is optional, and can be set in either
  \texttt{begin} or \texttt{finish}.  \texttt{finish} overrides
  \texttt{begin}.

\item [] \texttt{update}.  This optiong will be discussed in
section~\ref{sec:trunc-update}.
\end{itemize}

The Urd transaction database will be updated when the \texttt{finish}
function is called.  Before calling \texttt{finish}, nothing is
stored, and it is perfectly okay to omit \texttt{finish} during
development work.




\section{Timestamp Resolution}

Timestamps may be specified in various resolution depending on the
application.  The time format is
\begin{python}
"%Y-%m-%dT%H:%M:%S"
\end{python}
and it can be truncated as shown in the following examples covering
all possible cases.
\begin{python}
'2016-10-25'               day resolution
'2016-10-25T15'            hour resolution
'2016-10-25T15:25'         minute resolution
'2016-10-25T15:25:00'      second resolution
\end{python}



\section{Aborting an Urd Session}

When an Urd session is initiated, a new session cannot be started
until the current session has finished.  A session may be aborted,
however, using the \texttt{abort()} function, like this
\begin{python}
urd.begin('test')
urd.abort()
\end{python}
Aborted sessions are not stored in the Urd transaction log.




\section{Building Jobs}

Jobs are dispatched in Urd sessions using the \texttt{build} function.
The syntax is just the same as in the previous chapter that did not
use sessions, but will be repeated here for convenience.\\[-3ex]
\begin{python}
jobid = urd.build(method, options={}, datasets={}, jobids={}, name='', caption='')
\end{python}
The \texttt{name} is used to override the default name (which is the name of the method) in the Urd joblist.



\section{The Urd Item}

\begin{leftbar}
\begin{verbatim}
{
    "user": "ab"
    "automata": "BAR",
    "timestamp": "2018-01-04T2",
    "caption": "",
    "joblist": [
        [
            "example",
            "TEST-37"
        ]
    ],
    "deps": {
        "ab/FOO": {
            "timestamp": "2018-01-04T02"
            "caption": "",
            "joblist": [
                [
                    "example",
                    "TEST-34"
                ]
            ],
        }
    },
}
\end{verbatim}
\end{leftbar}

The Urd item is what is stored when a session completes.  It is
addressed by a key which is a timestamp, and the data is a dictionary.
The most imporant dictionary items are
\starttabletwo
\RPtwo \texttt{timestamp} & Timestamp of session\\[1ex]
\RPtwo \texttt{caption} & A caption\\[1ex]
\RPtwo \texttt{user/automata} & Location of urd-list\\[1ex]
\RPtwo \texttt{joblist} & An object of type \texttt{joblist}, containing all jobs built in the session.  For more information, see~\ref{xx}.\\[1ex]
\RPtwo \texttt{deps} & A dictionary of dependencies from \texttt{user/automata} to urd sessions, like this \mintinline{python}@{user/automata: session}@.\\[1ex]
\stoptabletwo








\section{Finding Items in Urd}

\subsection{Finding an Exact or Closest Match:  \texttt{get()}}
The \texttt{get()} function will return an item corresponding to a
(relaxed) timestamp.  (More about the relaxed part below.)
\begin{python}
urd.get("ab/test", "2018-01-01T23")
\end{python}
The timestamp must match exactly for an item to be returned.  This
strict behaviour can be relaxed by starting the timestamp with
``\texttt{<}'', ``\texttt{<=}'', ``\texttt{>}'', or ``\texttt{>=}'',
for example
\begin{python}
urd.get("ab/test", ">2018-01-01T01")
\end{python}
may return an item recorded as \texttt{2018-01-01T02}.

The timestamp may be relaxed in the sense that it is used for
comparison ``from the left'', so it is okay to do
\begin{python}
urd.get("ab/test", ">20")
\end{python}
to get the fist recorded item recorded in a year starting with ``20''.
Note that
\begin{python}
urd.get("ab/test", "<=2018-05")
\end{python}
will match all ``\texttt{2018-05-xx}''-timestamps.


\subsection{Finding the latest item:  \texttt{latest()}}
The \texttt{latest()} will return the item with most recent timestamp.
It can only be called in a running session, since it is logging the
result so it can be appended to the next built job.  Example
\begin{python}
urd.latest('ab/test')
\end{python}
will return a complete item like this
\begin{shell}
{'automata': 'test', 'caption': '', 'user': 'ab', 'deps': {}, \
 'joblist': JobList([('example', 'TEST-34')]), 'timestamp': '2018-05-06'}
\end{shell}


\subsection{Finding the first item:  \texttt{first()}}
The \texttt{first()} function works similarly to \texttt{latest}, and
will return the item with the oldest timestamp.



\section{Truncating and Updating}
\label{sec:trunc-update}
Since the Urd database is designed using log files, it will always
keep a consistent history of all events taken place.  It is not
possible to erase or modify old entries, but it is okay to update the
latest item, or set a marker in the log indicating that the list is
starting over from a certain date and everything before this marker
should not be considered anymore.

\subsection{Updating the last item}
To update the last item in a list, set the \texttt{update} argument
to \pyTrue
\begin{python}
urd.begin('test', '2016-10-25', update=True)
\end{python}
If update is \pyTrue, the entry in the test list at '2016-10-25' will
be updated, unless the new information is equivalent.

\subsection{Truncating a list}
In order to set a marker in the database indicating that everything
before a certain timestamp should be discarded, use
the \texttt{truncate()} function like this
\begin{python}
urd.truncate(ab/'test', '2016-09-30')
\end{python}
This will rollback everything that has happened in
the \texttt{ab/test} list back to '2016-09-30'.  There is also a
special case,
\begin{python}
urd.truncate('ab/test', 0)
\end{python}
that will erase all items from memory and cause the list to start over
again.  Remember, internally Urd stores the complete history in a log
file in plain text.  Files can only be appended to, nothing is ever
removed.




\section{Avoiding Recording Dependency}
Dependency-recording will be activated on use of the \texttt{get},
\texttt{latest}, and \texttt{first} functions.  If, for some reason,
the point is to just have a look at the database to see what is in
there, it can be done using the peek functions, \texttt{peek} and
\texttt{peek\_latest}, like this:
\begin{python}
urd.peek('test', '2016-10-25')
urd.peek_latest('test')
urd.peek_first('test')
\end{python}
Note that this is in general not recommended.  These functions will
look up Urd lists with jobids that may be used to build new jobs, but
these dependencies will not be stored in the current Urd session,
causing a loss of continuity and visibility.



\section{Other Convenience Functions}
\subsection{Listing all urd lists:  \texttt{list()}}
The \texttt{list()} function will return a list of all lists recorded in
the database:
\begin{python}
print(urd.list())
\end{python}
may show something like
\begin{shell}
['ab/test', 'ab/live']
\end{shell}


\subsection{Listing all Items After a Specific Timestamp:  \texttt{since()}}
The \texttt{since()} function is used to extract lists of timestamps
corresponding to urd entries.  In its most basic form, it is called
with a timestamp like this
\begin{python}
urd.since('2016-10-05')
\end{python}
which returns a list with all existing timestamps more recent than the
one provided
\begin{shell}
['2016-10-06', '2016-10-07', '2016-10-08', '2016-10-09', '2016-10-09T20']
\end{shell}
The \texttt{since} is rather relaxed with respect to the resolution of
the input.  The input timestamp may be truncated from the right down
to only one digits.  An input of zero is also valid.  For example,
these are all valid
\begin{python}
urd.since('0')
urd.since('2016')
urd.since('2016-1')
urd.since('2016-10-05')
urd.since('2016-10-05T20')
urd.since('2016-10-05T20:00:00')
\end{python}


\clearpage
\section{Talking directly to Urd:  The Urd HTTP-API}

Urd can be accessed directly without using the Accelerator by calling
its HTTP API.  In the following the standard tool \texttt{curl} is
used, and it is assumed that there is an Urd server running
on \texttt{localhost}, port \texttt{8833}.


\subsection{The \texttt{list} endpoint}
To show all stored lists issue
\begin{shell}
% curl http://localhost:8833/list
["ab/test"]
\end{shell}
All available lists are returned in a json list.


\subsection{The \texttt{since} endpoint}
The \texttt{since} endpoint is used to get a list of all entries more recent than a timestamp.
Fr example, to see what is more recent than \texttt{2016-10-24} do
\begin{shell}
% curl http://localhost:8833/ab/test/since/2016-10-24
["2016-10-25"]
\end{shell}
\begin{shell}
% curl http://localhost:8833/ab/test/since/2016-10-26
[]
\end{shell}
Results are in json list format.


\subsection{The \texttt{first} and \texttt{latest} endpoints}
Looking up the latest stored job in the \texttt{ab/test} list
\begin{shell}
% curl http://localhost:8833/ab/test/latest
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "2016-10-25", "joblist": [["method1", "test-56"],
  ["method2", "test-59"], ["method3", "test-60"]]}
\end{shell}
And see the first stored job in the test list
\begin{shell}
% curl http://localhost:8833/ab/test/first
\end{shell}
works similarly.  The returned data is an Urd item, described in
section~\ref{xx}, in json format.



\subsection{The \texttt{get} endpoint}
Actually, there is no explicit \texttt{get} endpoint.  Instead, the
API is just called by the name of the list and a timestamp.  For
example, to see what is inside the test list stored
at \texttt{2016-10-25}
\begin{shell}
% curl http://localhost:8833/ab/test/2016-10-25
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "2016-10-25", "joblist": [["method1", "test-56"],
  ["method2", "test-59"], ["method3", "test-60"]]}
\end{shell}
The timestamp may be truncated to the right, and prefixed
by \texttt{>}, \texttt{>=}, \texttt{<}, and texttt{<=}, just as
described in section~\ref{xx}.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
% Copyright (c) 2018 eBay Inc.                                             %
%                                                                          %
% Licensed under the Apache License, Version 2.0 (the "License");          %
% you may not use this file except in compliance with the License.         %
% You may obtain a copy of the License at                                  %
%                                                                          %
%  http://www.apache.org/licenses/LICENSE-2.0                              %
%                                                                          %
% Unless required by applicable law or agreed to in writing, software      %
% distributed under the License is distributed on an "AS IS" BASIS,        %
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. %
% See the License for the specific language governing permissions and      %
% limitations under the License.                                           %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{chap:urd}

This chapted is the continuation of the chapter~\ref{chap:urd_basic},
``Basic Build Scripting''.  Please read about build script and
joblists before proceeding.


\section{Introduction to Urd}

Build scripts, as presented in chapter~\ref{chap:urd_basic}, provides
a powerful way to build and link jobs.  In may cases, however, this is
not enough.  For example, when a project matures, there is a need for
separation, and if a project uses lots of input files, something is
needed to keep track of them.

Urd is the processing flow controller in the framework.  It is the
primary job dispatcher as well as the bookkeeper of all jobs executed.
It provides a way to look up existing jobs and datasets, and provides
separation in that it eliminates the need to replay build scripts to
find old jobids and datasets.  (It is also an interesting
log-file-based database, that will be further discussed in
section~\ref{xx}.)

Events in urd are separated into what is called \textsl{sessions}.
The core of Urd is a transaction log database storing these sessions
together with meta information.  The result is a server providing
lookups for all jobs executed together with their context.

The Urd database is partitioned into what is called \textsl{lists}.
Lists record sessions and key them using a timestamp.  Lists are
globally readable, but writing requires authentication, so that, for
example, only the production user may publish a model to go live.

With the exception of experimental work and the build script basics
presented in the previous chapter, all work initiated by Urd is run in
closed sessions, with well defined starting and ending points.  The
input parameters to these sessions are recorded as dependencies,
together with the resulting output.



\section{Urd Sessions}

Urd sessions exists between the \texttt{urd.begin()}
and \texttt{urd.finish()} functions, like in this minimal example
\begin{python}
def main(urd):
    urd.begin('user/test', '2018-05-09')
    ...
    urd.finish('user/test')
\end{python}
All jobs dispatched between \texttt{begin} and \texttt{finish} will be
appended to the \texttt{user/test} \textsl{Urd list} with
timestamp \texttt{2018-05-09}.  This also includes meta information,
such as all lookups of jobs done by Urd in the session that will be
appended as dependencies.

There are a number of options associated with a session, as shown
here,
\begin{python}
urd.begin(urdlist, timestamp, caption=None, update=False)
urd.finish(urdlist, timestamp, caption=None)
\end{python}
and the following applies
\begin{itemize}
\item [] \texttt{urdlist} is the name of the Urd list, and the same
  \texttt{urdlist} must be specified in both \texttt{begin}
  and \texttt{finish}.  The \texttt{urdlist} is specified as
  ``\texttt{user/list}'', where the ``\texttt{user/}'' part is
  optional.  The \texttt{user} should correspond to the
  current \texttt{URD\_AUTH} settings, see section~\ref{xxx}.

\item [] \texttt{timestamp} is mandatory, but could be set in either
  \texttt{begin}, \texttt{finish}, or both.  \texttt{finish}
  overrides \texttt{begin}.

\item [] \texttt{caption} is optional, and can be set in either
  \texttt{begin} or \texttt{finish}.  \texttt{finish} overrides
  \texttt{begin}.

\item [] \texttt{update}.  This optiong will be discussed in
section~\ref{sec:trunc-update}.
\end{itemize}

The Urd transaction database will be updated when the \texttt{finish}
function is called.  Before calling \texttt{finish}, nothing is
stored, and it is perfectly okay to omit \texttt{finish} during
development work.




\subsection{Timestamp Resolution}

Timestamps may be specified in various resolution depending on the
application.  The time format is
\begin{python}
"%Y-%m-%dT%H:%M:%S"
\end{python}
and it can be truncated as shown in the following examples covering
all possible cases.
\begin{python}
'2016-10-25'               day resolution
'2016-10-25T15'            hour resolution
'2016-10-25T15:25'         minute resolution
'2016-10-25T15:25:00'      second resolution
\end{python}



\subsection{Aborting an Urd Session}

When an Urd session is initiated, a new session cannot be started
until the current session has finished.  A session may be aborted,
however, using the \texttt{abort()} function, like this
\begin{python}
urd.begin('test')
urd.abort()
\end{python}
Aborted sessions are not stored in the Urd transaction log.




\section{Building Jobs}

Jobs are dispatched in Urd sessions using the \texttt{build} function.
The syntax is just the same as in the previous chapter that did not
use sessions, but will be repeated here for convenience.\\[-3ex]
\begin{python}
jobid = urd.build(method, options={}, datasets={}, jobids={}, name='', caption='')
\end{python}
The \texttt{name} is used to override the default name (which is the name of the method) in the Urd joblist.



\section{The Urd Item}



\section{Urd Sessions with Dependencies}

Perhaps it is easiest to explain this using an example.  In order to
keep things separate in a project, data import and data processing is
separated into different build scripts.

The next section provides a simple example import script

\subsection{Example}
\begin{python}
def main(urd):
    urd.begin('import/txn', '2018-05-03')
    urd.build('csvimport', options=dict(filename='txn1.txt'))
    urd.finish('import/txn')
\end{python}
(Larger, more realtime, projects, may create one Urd session per hour
or day, depending on how often new data is added to the system.)

The import script has stored the session's joblist to Urd in the
list \texttt{import/txn} and timestamp \texttt{2018-05-03}.  It can
now be used by other build scripts.

An example data processing script may look like the following
\begin{python}
def main(urd):
    urd.begin('process/test')
        import_session = urd.latest('import/txn')
        import_timestamp = import_session.timestamp
        import_jobid = import_session.joblist.jobid
        urd.build('process', datasets=dict(source=import_jobid))
    urd.finish('process/test', import_timestamp)
\end{python}
This script fetches the \textsl{latest} import in
the \texttt{import/txn} list, processes the corresponding dataset, and
stores the session to the \texttt{process/test} list using
the \textsl{same} timestamp as the imported file.  This makes a lot of
sense, and is very good for tracking purposes.




\subsection{Finding Items in Urd}

\subsubsection{get}
The \texttt{get()} function will return an item corresponding to a
(relaxed) timestamp.  (More about the relaxed part below.)
\begin{python}
urd.get("ab/test", "2018-01-01T23")
\end{python}
The timestamp must match exactly for an item to be returned.  This
strict behaviour can be relaxed by starting the timestamp with
``\texttt{<}'', ``\texttt{<=}'', ``\texttt{>}'', or ``\texttt{>=}'',
for example
\begin{python}
urd.get("ab/test", ">2018-01-01T01")
\end{python}
may return an item recorded as \texttt{2018-01-01T02}.

The timestamp may be relaxed in the sense that it is used for
comparison ``from the left'', so it is okay to do
\begin{python}
urd.get("ab/test", ">20")
\end{python}
to get the fist recorded item recorded in a year starting with ``20''.
Note that
\begin{python}
urd.get("ab/test", "<=2018-05")
\end{python}
will match all ``\texttt{2018-05-xx}''-timestamps.


\subsubsection{latest}
The \texttt{latest()} will return the item with most recent timestamp.
It can only be called in a running session, since it is logging the
result so it can be appended to the next built job.  Example
\begin{python}
print(urd.latest('ab/test')
\end{python}
will return a complete item like this
\begin{shell}
{'automata': 'test', 'caption': '', 'user': 'ab', 'deps': {}, \
 'joblist': JobList([('example', 'TEST-34')]), 'timestamp': '2018-05-06'}
\end{shell}


\subsubsection{first}
The \texttt{first()} function works similarly to \texttt{latest}, and
will return the item with the oldest timestamp.


xxx

xxx

xxx



A job may have dependencies, such as other jobs or datasets.  These
dependencies are input to the job using the corresponding arguments to
the \texttt{build} function.  Locating these jobs or datasets,
however, is exactly a design goal of Urd.  Urd implements a
\texttt{get} function that looks up jobids and dependencies from a key
that is composed of an Urd list name plus a timestamp.  There are
also, for convenience, \texttt{first} and \texttt{latest} functions to
get the first and latest job in an Urd list.

Here is an example.  Assume that we have a build script that imports
data files.  Information about the import jobs is stored in the
\texttt{import} Urd list.
\begin{python}
def main(urd):
    now = '2018-04-03'
    urd.begin('import', now)
    jid_prev = urd.latest('import')
    urd.build('csvimport',
        options=dict(filename='log' + now + '.txt',),
        datasets=dict(previous=jid_prev)
    )
    urd.finish('import')
\end{python}
Note how the \texttt{previous} dataset is assigned from the output of
the \texttt{urd.latest} call, making the import jobs \textsl{chained}.
The call to \texttt{latest} will be recorded in the \texttt{import}
Urd list as well.

Now, assume that a method \texttt{computesomething}, uses these
imported datasets.  When dispatching \texttt{computesomething}, it
should be using the latest available \texttt{import}.  This example
shows again how the function \texttt{latest} is used for this purpose
\begin{python}
def main(urd):
    urd.begin('test')
    latest_import = urd.latest('import').joblist.jobid
    urd.build('computesomething', datasets=dict(source=latest_import))
    urd.finish('test', '2018-04-03')
\end{python}
Two things have happened here.  First, urd has provided a jobid link
to the latest available \texttt{import} dataset.  Second, the
dependency of exactly this version of \texttt{import} to
\texttt{computesomething} is recorded in the urd list \texttt{test}
for timestamp \texttt{20180403}.  So, if there is a question in the
future which version of the \texttt{import} database that was used on
that date for the \texttt{computesomething} function, it is
immediately available from urd.

The more general form is \texttt{get}, which is shown below together
with its derived convenience-functions
\begin{python}
    urd.get('test', '2016-10-01')
    urd.latest('test')
    urd.first('test')
\end{python}
And here is an example of running \texttt{computesomething} on \texttt{import} data
from previous month
\begin{python}
def main(urd):
    urd.begin('test')
    import = urd.get('import', '2016-09-25').joblist.jobid
    urd.build('computesomething', datasets=dict(import=import))
    urd.finish('test', '2016-10-25')
\end{python}



\section{Avoiding Recording Dependency}
Dependency-recording will be activated on use of the \texttt{get},
\texttt{latest}, and \texttt{first} functions.  If, for some reason,
the point is to just have a look at the database to see what is in
there, it can be done using the peek functions, \texttt{peek} and
\texttt{peek\_latest}, like this:
\begin{python}
    urd.peek('test', '2016-10-25')
    urd.peek_latest('test')
    urd.peek_first('test')
\end{python}
Note that this is in general not recommended.  These functions will
look up Urd lists with jobids that may be used to build new jobs, but
these dependencies will not be stored in the current Urd session,
causing a loss of continuity and visibility.



\section{More on Finding Items in Urd}
\texttt{get}, \texttt{first}, and \texttt{latest} all return an urd item.


\subsection{get}



\subsection{latest}
The \texttt{latest()} will return the item with most recent timestamp.
It can only be called in a running session, since it is logging the
result so it can be appended to the next built job.  Example
\begin{python}
print(urd.latest('ab/test')
\end{python}
will return a complete item like this
\begin{shell}
{'automata': 'test', 'caption': '', 'user': 'ab', 'deps': {}, \
 'joblist': JobList([('example', 'TEST-34')]), 'timestamp': '2018-05-06'}
\end{shell}


\subsection{first}
The \texttt{first()} function works similarly to \texttt{latest}, and
will return the item with the oldest timestamp.


\subsection{list}
The \texttt{list()} function will return a list of all lists recorded in
the database:
\begin{python}
print(urd.list())
\end{python}
may show something like
\begin{shell}
['ab/test', 'ab/live']
\end{shell}


\subsection{since}
The \texttt{since()} function is used to extract lists of timestamps
corresponding to urd entries.  In its most basic form, it is called
with a timestamp like this
\begin{python}
print(urd.since('2016-10-05'))
\end{python}
which returns a list with all existing timestamps more recent than the
one provided
\begin{shell}
['2016-10-06', '2016-10-07', '2016-10-08', '2016-10-09', '2016-10-09T20']
\end{shell}
The \texttt{since} is rather relaxed with respect to the resolution of
the input.  The input timestamp may be truncated from the right down
to only one digits.  An input of zero is also valid.  For example,
these are all valid
\begin{python}
print(urd.since('0'))
print(urd.since('2016'))
print(urd.since('2016-1'))
print(urd.since('2016-10-05'))
print(urd.since('2016-10-05T20'))
print(urd.since('2016-10-05T20:00:00'))
\end{python}







\section{Truncating and Updating}
\label{sec:trunc-update}
Since the Urd database is designed using log files, it will always
keep a consistent history of all events taken place.  It is not
possible to erase or modify old entries, but it is okay to update the
latest or set a marker in the log indicating that the list is starting
over from a certain date and everything before this marker should not
be considered anymore.

To update a list, use the \texttt{update} argument
\begin{python}
urd.begin('test', '20161025', update=True)
\end{python}
If update is True, the entry in the test list at '20161025' will be
updated, unless there has been no change.  and in order to set a
marker in the database indicating that everything before a certain
date in time should be discarded, do like this
\begin{python}
urd.truncate('test', '20160930')
\end{python}
This will rollback everything that has happened in the \texttt{test}
list back to '20160930'.  Remember, internally Urd stores the complete
history in a log file in plain text.


\section{More on Joblist and Jobtuple}

Urd is using the type joblist to keep track of successfully executed
jobs.  Each item in the joblist is of type jobtuple.  This section
will start by describing jobtuple first and then joblist.

\subsubsection{Jobtuple}

The \jobtuple type is used to group method names and corresponding
jobids.  It is basically a tuple with some extra properties, such as a
conversion of a jobtuple to \texttt{str}, which happens for example
when printing it, returns the jobid as a string.

\begin{python}
>>> jt = JobTuple('imprt', 'jid-0')

>>> jt
('imprt', 'jid-0')
\end{python}
as expected, and

\begin{python}
>>> jt.method
'imprt'

>>> jt.jobid
'jid-0'
\end{python}
but note that

\begin{python}
>>> print(jt)  # str and encode return jobid only
jid-0
\end{python}



\subsubsection{JobList}

\label{sec:joblist}
The \joblist is a list with add-ons for bookkeeping and finding jobs.
It stores instances of \jobtuple.  Here is an example.  First, define
a \jobtuple

\begin{python}
>>> jt = JobTuple('imprt', 'jid-0')
\end{python}
then define a joblist initiated with the same tuple.  Then append some
more jobs directly using the \texttt{append} method.

\begin{python}
>>> jl = JobList(jt)
>>> jl.append('learn', 'lrn-0')
>>> jl.append('imprt', 'imp-1')
\end{python}
Let's see how and what is stored in the \joblist.  The \texttt{pretty}
method is quite useful, but note that just printing the object will
show the last jobid only.

\begin{python}
>>> print(jl.pretty)
JobList(
   [  0]  imprt : jid-0
   [  1]  learn : lrn-0
   [  2]  imprt : imp-1
)

>>>  print(jl)  # jobid of latest appended JobTuple
imp-1
\end{python}

It is easy to retrieve the last job with a particular \texttt{method}
name, either by lookup or by using \texttt{find}.

\begin{python}
>>> jl['imprt']         # latest jobid with name 'imprt'
('imprt', 'imp-1')

>>> print(jl['imprt'])   # jl['imprt'] is JobTuple
imp-1
\end{python}
The Find method returns a \joblist.  Slicing also returns {\joblist}s

\begin{python}
>>> jl.find('imprt')
JobList([('imprt', 'jid-0'), ('imprt', 'imp-1')])

>>> jl[:2]
JobList([('imprt', 'jid-0'), ('learn', 'lrn-0')])
\end{python}
Looking up by index returns \jobtuple.

\begin{python}
>>> jl[0]
('imprt', 'jid-0')
\end{python}
These conveniences are also supported

\begin{python}
>>> jl.all              # list of all jobids
'jid-0,lrn-0,imp-1'

>>> jl.method           # last method
'import'

>>> jl.jobid            # last jobid
'imp-1'
\end{python}



\newpage
\section{Talking directly to Urd:  The Urd HTTP-API}

In some situations it is convenient to make calls to urd directly
without using the framework.  Urd will react to HTTP requests, so a
tool like \texttt{curl} suffice.

\noindent Show all stored lists like this
\begin{shell}
% curl http://localhost:8833/list
["ab/test"]
\end{shell}

Looking up the latest stored job in the test list
\begin{shell}
% curl http://localhost:8833/ab/test/latest
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "20161025", "joblist": [["method1", "test-56"],
  ["method2", "test-59"], ["method3", "test-60"]]}
\end{shell}
And see the first stored job in the test list
\begin{shell}
% curl http://localhost:8833/ab/test/first
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "20161025", "joblist": [["method1", "test-56"],
  ["method2", "test-59"], ["method3", "test-60"]]}
\end{shell}
See what is inside the test list stored at \texttt{20161025}
\begin{shell}
% curl http://localhost:8833/ab/test/20161025
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "20161025", "joblist": [["method1", "test-56"],
  ["method2", "test-59"], ["method3", "test-60"]]}
\end{shell}
And what is avaible in the test list that is more recent than \texttt{20161024}
\begin{shell}
% curl http://localhost:8833/ab/test/since/20161024
["20161025"]
\end{shell}
\begin{shell}
% curl http://localhost:8833/ab/test/since/20161026
[]
\end{shell}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
% Copyright (c) 2018 eBay Inc.                                             %
%                                                                          %
% Licensed under the Apache License, Version 2.0 (the "License");          %
% you may not use this file except in compliance with the License.         %
% You may obtain a copy of the License at                                  %
%                                                                          %
%  http://www.apache.org/licenses/LICENSE-2.0                              %
%                                                                          %
% Unless required by applicable law or agreed to in writing, software      %
% distributed under the License is distributed on an "AS IS" BASIS,        %
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. %
% See the License for the specific language governing permissions and      %
% limitations under the License.                                           %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\label{chap:urd}

This chapted is the continuation of the chapter~\ref{chap:urd_basic},
``Basic Build Scripting''.  Please read about build script and
joblists before proceeding.


\section{Introduction to Urd}

Urd comes into play when simple build scripting is not enough.  A wide
variety of advanced tasks can be handled without it, but the
capabilities added by Urd in terms of job organisation, storage, and
retreival makes it possible to handle much larger and more advanced
projects while maintaining in full control.

Using Urd, a project could be separated into functionally independent
parts, and all dependencies between jobs inside as well as between
these parts is logged.  It is possible to re-construct the state of
any part the way it were at any instance in time.

More formally, Urd provides two things:
\begin{itemize}
\item[1.] Separation between build scripts,
        and a way to share information about built jobs between
        different scripts (or the same script at different points in time).
\item[2.] A searchable transaction log database of all jobs built
together with their dependencies.
\end{itemize}
The interesting transaction log database and many other aspects of Urd
will be explained in the rest of this chapter.




\section{A Simple Usecase}

Assume a project where, say, movie recommendation data is to be
analysed.  Every hour, recommendations generated during the last hour
will appear in the shape of a new log file.  The project is using two
build scripts:
\begin{itemize}
\item[] The first build script is used to look for new files, and import and chain
  them as they appear.  For each new file imported, the build script
  will tell the Urd server the timestamp of the file as well as a list
  of all created jobs associated with that file.

\item[] The second build script is used for the data analysis work, and is perhaps run less regularly.
  This script needs to know the jobid to the latest imported file, and
  this is a straightforward thing to ask Urd.  All analysis jobs are
  also stored in Urd together with a corresponding timestamp.
\end{itemize}
Here, Urd is used to forward information about executed jobs from
first build script to the second.  In this senss, Urd
provides \textsl{isolation} by message passing.

Urd can also be used to tell which input data that was used for a
particular data analysis job.  When quering Urd about a data analysis
job, it will respond with information about those jobs \textsl{as well
as} information about all Urd queries that was neccesary for the jobs
to run.  This information is stored automatically in the build script
and it is there to ensure transparency and reproducibility.






%% \section{Urd Concepts}

%% Before going into any details, here is a list with description of the
%% main Urd concepts.

%% \begin{itemize}
%% \item[]  \textsl{Build scripts}, as presented in chapter~\ref{chap:urd_basic},
%% provide a powerful way to build and link jobs.  A larger project may
%% use sevaral build scripts.

%% \item[] \textsl{joblist}s.  A running build script will automatically
%% record information about all built jobs in the \texttt{urd.joblist}
%% variable.


%% \item[] A \textsl{session} is what happens between the first and last
%% addition of information to this variable.

%% \item[] \textsl{Urd lists}...

%% \end{itemize}
%% The Urd database is partitioned into what is called \textsl{lists}.
%% Each element in such a list is a joblist that represents a session.
%% Lists are associated by keys in the format \texttt{<user>/<name>}, and
%% individual elements (sessions) in the lists are associated with a
%% timestamp.  Lists are globally readable, but writing requires
%% authentication, so that, for example, only the production user may
%% publish a model to go live.

%% \comment{det behovs en bild har!}



\section{Urd Sessions and Lists}

A simple file import script will be used as example in this section.
Remember from chapter~\ref{} how to import a file in a build script:
\begin{python}
def main(urd):
    urd.build('csvimport', options=dict(filename='txn1.txt'))
\end{python}
In order to use this import job in a future context,
a \textsl{session} is created by wrapping the code by
the \texttt{urd.begin()} and \texttt{urd.finish()} functions, like this
\begin{python}
def main(urd):
    urd.begin('import/txn', '2018-05-03')
    urd.build('csvimport', options=dict(filename='txn1.txt'))
    urd.finish('import/txn')
\end{python}
This session is, at completion time, stored premanently in an
Urd \textsl{list} for future reference.  The name of this list is
\begin{verbatim}
    import/txn
\end{verbatim}
and the timestamp is
\begin{verbatim}
    2018-05-03
\end{verbatim}
As will be shown next, the session can be looked up using the name of
the \textsl{list} and the \textsl{timestamp}.




\section{A First Urd Query}

The list created in the previous section can now be used by other
build scripts.  For example, here is a build script that does some
processing on the previously imported file
\begin{python}
def main(urd):
    urd.begin('process/test')

    import_session = urd.latest('import/txn')

    import_timestamp = import_session.timestamp
    import_jobid     = import_session.joblist.jobid

    urd.build('process', datasets=dict(source=import_jobid))

    urd.finish('process/test', import_timestamp)
\end{python}
First, the recently created urd session stored in
list \texttt{import/txn} is retrieved.  Two things are extracted from
this data.  First, the timestamp of the import session.  This
timestamp will be used as key for the ongoing \texttt{process/test}
session as well, indicating that it is based on data from the same
time instance.  Furthermore, the jobid to the \texttt{csvimport} job
is extracted and fed to the \texttt{process} job as an input dataset
parameter.  (The slightly clumsy syntax for this is explained in
section~\ref{}.)



\section{Urd Sessions:  \texttt{begin()} and \texttt{finish()}}

There are a number of options associated with a session, as shown
here,
\begin{python}
urd.begin(urdlist, timestamp, caption=None, update=False)
urd.finish(urdlist, timestamp, caption=None)
\end{python}
and the following applies
\starttabletwo
\RPtwo \texttt{urdlist} & is the name of the Urd list, and the same
  \texttt{urdlist} must be specified in both \texttt{begin()}
  and \texttt{finish()}.

  The \texttt{urdlist} is specified as ``\texttt{user/list}'', where
  the ``\texttt{user/}'' part is optional.  The \texttt{user} string
  is also for authentication, and must correspond to the
  current \texttt{URD\_AUTH} settings, see section~\ref{xxx}.\\[2ex]

\RPtwo \texttt{timestamp} & is \textsl{mandatory}, but could be set in either
  \texttt{begin()}, \texttt{finish()}, or both.  \texttt{finish()}
  will override \texttt{begin()}.\\[2ex]

\RPtwo \texttt{caption} & is \textsl{optional}, and can be set in either
  \texttt{begin()} or \texttt{finish()}.  \texttt{finish()}
  will override \texttt{begin()}.\\[2ex]

\RPtwo \texttt{update} &  If set to \pyTrue, the last item in the list may be updated.
  This optiong will be discussed in section~\ref{sec:trunc-update}.\\[2ex]
\stoptabletwo

The Urd transaction database will be written to only when
the \texttt{finish()} function is called.  Before
calling \texttt{finish()}, nothing is stored, and it is perfectly okay
to omit \texttt{finish()} to avoid storage or during development work.



\section{What Urd Stores}

Calling \texttt{urd.finish()} will update the Urd database with the
contents of the current \textsl{session}.  Each session is addressable
using a \textsl{list} name (in the format \texttt{user/automata}) and
a \textsl{timestamp}.  The example presented earlier in this chapter
may be retrieved using the
\begin{verbatim}
    processing/test
\end{verbatim}
list and timestamp
\begin{verbatim}
    2018-05-03
\end{verbatim}
Here is an example of what may have been recorded\begin{leftbar}
\begin{verbatim}
{
    "user": "processing"
    "automata": "test",
    "timestamp": "2018-05-03",
    "caption": "",
    "joblist": [
        [
            "process",
            "TEST-37"
        ]
    ],
    "deps": {
        "import/txn": {
            "timestamp": "2018-05-03"
            "caption": "",
            "joblist": [
                [
                    "csvimport",
                    "TEST-34"
                ]
            ],
        }
    },
}
\end{verbatim}
\end{leftbar}
\noindent This example states that at timestamp \texttt{2018-05-03} in list \texttt{processing/test},
there exists a \texttt{process} job with jobid \texttt{TEST-34} that
used a \texttt{csvimport} job with jobid \texttt{TEST-34}.

The most imporant dictionary items are
\starttabletwo
\RPtwo \texttt{timestamp} & Timestamp of session\\[1ex]
\RPtwo \texttt{caption} & A caption\\[1ex]
\RPtwo \texttt{user/automata} & Name of Urd list\\[1ex]
\RPtwo \texttt{joblist} & An object of type \texttt{joblist}, containing all jobs built in the session.  For more information, see~\ref{xx}.\\[1ex]
\RPtwo \texttt{deps} & A dictionary of dependencies from \texttt{user/automata} to urd sessions: \mintinline{python}@{'user/automata': session}@.\\[1ex]
\stoptabletwo




\section{Timestamp Resolution}

Timestamps may be specified in various resolution depending on the
application.  The full time format is (See Python's \texttt{datetime}
module for explanation.)
\begin{shell}
'%Y-%m-%dT%H:%M:%S'
\end{shell}
A specific timestamp could be shorter than the above specification in
order to cover wider time ranges.  The following examples cover all
possible cases.
\begin{python}
'2016-10-25'               # day resolution
'2016-10-25T15'            # hour resolution
'2016-10-25T15:25'         # minute resolution
'2016-10-25T15:25:00'      # second resolution
\end{python}



\section{Aborting an Urd Session:  \texttt{abort()}}

When an Urd session is initiated, a new session cannot be started
until the current session has finished.  A session may therefore be
aborted, and the \texttt{abort()} function is used for this, like so
\begin{python}
urd.begin('test')
urd.abort()
\end{python}
Similar to unfinished sessions, aborted sessions will not be stored in
the Urd transaction log.




\section{Building Jobs: \texttt{build()}}

Jobs are dispatched in Urd sessions using the \texttt{build} function.
Here is the complete call with all possible parameters.
\begin{python}
jobid = urd.build(
    method,
    options={},    datasets={},    jobids={},
    name='',       caption='',
    workdir=None
)
\end{python}
Explanation of \texttt{build} parameters:
\starttabletwo
\RPtwo \texttt{method} & Name of method to build.  Enter \texttt{test}
    here if the method filename is \texttt{a\_test.py}.\\[2ex]
    
\RPtwo \texttt{options=\{\}} & a \texttt{dict} of options to the method.
    This overrides options defined in the method itself, but adding
    options not prototyped in the method is \textsl{not} allowed.\\[2ex]

\RPtwo \texttt{jobids=\{\}} & a \texttt{dict} of jobids to the method.
    It is possible to specify a list of jobids like this
\begin{python}
jobids=dict{alljobs=[jobid1, jobid2,...]}
\end{python}
\\[0ex]

\RPtwo \texttt{datasets=\{\}} & a \texttt{dict} of datasets to the method.
    Datasets may be lists too, just like \texttt{jobids} above.\\[2ex]

\RPtwo \texttt{workdir=None} & If specified, the job will be built in
    this workdir, assuming the workdir is specified in the
    configuration file as either source or target.\\[2ex]

\RPtwo \texttt{name} & A string associated with the job.  Use it
    to distinguish several jobs created from the same method.\\[2ex]
    \texttt{caption} & A caption string.  For decorative purposes
    only, this has no practical use.
\stoptabletwo

The \texttt{build()} function will only build a job when it has to,
otherwise it will just return a link (jobid) to a matching existing
job.  In order to match, an existing job must have
\begin{itemize}
\item[-] exactly the same source code, i.e.\ the \textsl{hash} of the source code must match,
\item[-] exactly the same options, datasets, and jobids.
\end{itemize}
If the source code is changes, a job rebuild can be prevented using
the \texttt{equivalent\_hashes} variable as explained in
section~\ref{}.



\section{Changing workdir:  \texttt{set\_workdir()}}
The target workdir specified in the configuration file is the only
workdir that is written to by default.  Any other workdir is read
only.  This behaviour can be overrided, either
\begin{itemize}
\item[] per job, using the \texttt{workdir=...} option to \texttt{urd.build} as shown in section~\ref{}, or
\item[] using \texttt{urd.set\_workdir()}.
\end{itemize}
The latter,
\begin{python}
def main(urd):
    urd.set_workdir(<workdir>)}
\end{python}
will set the workdir for all coming \texttt{build} calls in the
current build script.  It can still be overrided using
the \texttt{workdir=} option to \texttt{urd.build}.












\section{Finding Items in Urd}

\subsection{Finding an Exact or Closest Match:  \texttt{get()}}
The \texttt{get()} function will return an item corresponding to a
timestamp, like this
\begin{python}
urd.get("ab/test", "2018-01-01T23")
\end{python}
The timestamp must match exactly for an item to be returned.  This
strict behaviour can be relaxed by starting the timestamp with
one of
\begin{itemize}
\item[] ``\texttt{<}'', ``\texttt{<=}'', ``\texttt{>}'', or ``\texttt{>=}''.
\end{itemize}
for example
\begin{python}
urd.get("ab/test", ">2018-01-01T01")
\end{python}
may return an item recorded as \texttt{2018-01-01T02}.  Relaxed
comparison is performed ``from left to right'', meaning that
\begin{python}
urd.get("ab/test", ">20")
\end{python}
will match the first recorded sesstion in a year starting with
``\texttt{20}'', while
\begin{python}
urd.get("ab/test", "<=2018-05")
\end{python}
will match the latest timestamp starting with ``\texttt{2018-05}'' or less,
such as ``\texttt{2018-04-01}'' or ``\texttt{2018-05-31T23:59:59}''.

\comment{get() ger en eller alla?  Måste skapa exempelkod!}

\subsection{Finding the latest item:  \texttt{latest()}}
The \texttt{latest()} will return the item with most recent timestamp.
It can only be called in a running session, since it is logging the
result so it can be appended to the next built job.  Example
\begin{python}
urd.latest('ab/test')
\end{python}
will return a complete item like this
\begin{shell}
{'automata': 'test', 'caption': '', 'user': 'ab', 'deps': {}, \
 'joblist': JobList([('example', 'TEST-34')]), 'timestamp': '2018-05-06'}
\end{shell}


\subsection{Finding the first item:  \texttt{first()}}
The \texttt{first()} function works similarly to \texttt{latest}, and
will return the item with the oldest timestamp.



\section{Truncating and Updating}
\label{sec:trunc-update}
Since the Urd database is designed using log files, it will always
keep a consistent history of all events taken place.  It is not
possible to erase or modify old entries, but it is okay to update the
latest item, or set a marker in the log indicating that the list is
starting over from a certain date and everything before this marker
should not be considered anymore.
\comment{history rewriting while maintaining full history!}



\subsection{Updating the last item}
To update the last item in a list, set the \texttt{update} argument
to \pyTrue
\begin{python}
urd.begin('test', '2016-10-25', update=True)
\end{python}
If update is \pyTrue, the entry in the test list at '2016-10-25' will
be updated, unless the new information is equivalent.

\subsection{Truncating a list}
In order to set a marker in the database indicating that everything
before a certain timestamp should be discarded, use
the \texttt{truncate()} function like this
\begin{python}
urd.truncate(ab/'test', '2016-09-30')
\end{python}
This will rollback everything that has happened in
the \texttt{ab/test} list back to '2016-09-30'.  There is also a
special case,
\begin{python}
urd.truncate('ab/test', 0)
\end{python}
that will erase all items from memory and cause the list to start over
again.  Remember, internally Urd stores the complete history in a log
file in plain text.  Files can only be appended to, nothing is ever
removed.




\section{Avoiding Recording Dependency}
Dependency-recording will be activated on use of the \texttt{get},
\texttt{latest}, and \texttt{first} functions.  If, for some reason,
the point is to just have a look at the database to see what is in
there, it can be done using the peek functions, \texttt{peek} and
\texttt{peek\_latest}, like this:
\begin{python}
urd.peek('test', '2016-10-25')
urd.peek_latest('test')
urd.peek_first('test')
\end{python}
Note that this is in general not recommended.  These functions will
look up Urd lists with jobids that may be used to build new jobs, but
these dependencies will not be stored in the current Urd session,
causing a loss of continuity and visibility.



\section{Other Convenience Functions}
\subsection{Listing all urd lists:  \texttt{list()}}
The \texttt{list()} function will return a list of all lists recorded in
the database:
\begin{python}
print(urd.list())
\end{python}
may show something like
\begin{shell}
['ab/test', 'ab/live']
\end{shell}



\subsection{Listing all Items After a Specific Timestamp:  \texttt{since()}}
The \texttt{since()} function is used to extract lists of timestamps
corresponding to urd entries.  In its most basic form, it is called
with a timestamp like this
\begin{python}
urd.since('2016-10-05')
\end{python}
which returns a list with all existing timestamps more recent than the
one provided
\begin{shell}
['2016-10-06', '2016-10-07', '2016-10-08', '2016-10-09', '2016-10-09T20']
\end{shell}
The \texttt{since} is rather relaxed with respect to the resolution of
the input.  The input timestamp may be truncated from the right down
to only one digits.  An input of zero is also valid.  For example,
these are all valid
\begin{python}
urd.since('0')
urd.since('2016')
urd.since('2016-1')
urd.since('2016-10-05')
urd.since('2016-10-05T20')
urd.since('2016-10-05T20:00:00')
\end{python}



\section{Truncation Consequences:  Ghosts}
When a list is truncated, all items after a specified timestamp are
made invisible.  Assuming that another list has stored a dependency of
an item that is truncated, the jobs in this list are now without
depencencies that can be looked up.  We call them ``ghosts''.  Ghosts
cannot be looked up in Urd, but they are still in the database, marked
as ghosts.



\clearpage
\section{Talking directly to Urd:  The Urd HTTP-API}

Urd can be accessed directly without using the Accelerator by calling
its HTTP API.  In the following the standard tool \texttt{curl} is
used, and it is assumed that there is an Urd server running
on \texttt{localhost}, port \texttt{8833}.


\subsection{The \texttt{list} endpoint}
To show all stored lists issue
\begin{shell}
% curl http://localhost:8833/list
["ab/test"]
\end{shell}
All available lists are returned in a json list.


\subsection{The \texttt{since} endpoint}
The \texttt{since} endpoint is used to get a list of all entries more recent than a timestamp.
Fr example, to see what is more recent than \texttt{2016-10-24} do
\begin{shell}
% curl http://localhost:8833/ab/test/since/2016-10-24
["2016-10-25"]
\end{shell}
\begin{shell}
% curl http://localhost:8833/ab/test/since/2016-10-26
[]
\end{shell}
Results are in json list format.


\subsection{The \texttt{first} and \texttt{latest} endpoints}
Looking up the latest stored job in the \texttt{ab/test} list
\begin{shell}
% curl http://localhost:8833/ab/test/latest
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "2016-10-25", "joblist": [["method1", "test-56"],
  ["method2", "test-59"], ["method3", "test-60"]]}
\end{shell}
And see the first stored job in the test list
\begin{shell}
% curl http://localhost:8833/ab/test/first
\end{shell}
works similarly.  The returned data is an Urd item, described in
section~\ref{xx}, in json format.



\subsection{The \texttt{get} endpoint}
Actually, there is no explicit \texttt{get} endpoint.  Instead, the
API is just called by the name of the list and a timestamp.  For
example, to see what is inside the test list stored
at \texttt{2016-10-25}
\begin{shell}
% curl http://localhost:8833/ab/test/2016-10-25
{"caption": "", "automata": "test", "user": "ab", "deps": {},
  "timestamp": "2016-10-25", "joblist": [["method1", "test-56"],
  ["method2", "test-59"], ["method3", "test-60"]]}
\end{shell}
The timestamp may be truncated to the right, and prefixed
by \texttt{>}, \texttt{>=}, \texttt{<}, and texttt{<=}, just as
described in section~\ref{xx}.



\section{Profiling a Build Script:  \texttt{print\_profile()}}
There is a helper function in the urd object that can be used to print
profiling information.  The following example is self-explanatory
\begin{python}
def main(urd):
    ...
    urd.print_profile()
\end{python}
This will print execution times for all jobs in the session
to \texttt{stdout}.  It may for example look like this
\begin{verbatim}
Time per method:
   color2        23.7 seconds  (25%)
   csvexport     17.5 seconds  (18%)
   lowpass2      15.6 seconds  (17%)
   newcol        14.4 seconds  (15%)
   black         5.7 seconds  (6%)
   colimage      5.4 seconds  (6%)
   sync          4.7 seconds  (5%)
   clamp         3.8 seconds  (4%)
   dataset_type  2.7 seconds  (3%)
   csvimport     1.4 seconds  (1%)
Total time 94.8 seconds
\end{verbatim}
The methods are sorted by execution time, longest execution first.


\section{Passing Flags from the Command Line}
It is possible to add a comma separated list of flags to the runner
like this
\begin{python}
./automatarunner.py --flags=verbose,skiptest
\end{python}
The flags will appear in the \texttt{urd}-object like this
\begin{python}
def main(urd):
    if 'verbose' in urd.flags:
       print('verbosity')
\end{python}


\clearpage
\section{Urd Internals}
Urd can be accessed by a large number of clients.  Each client may add
to or truncate any list at any time.  In order to avoid race
conditions and make the database deterministic, all \texttt{add}-
and \texttt{truncate}-requests appears in a sequential manner to the
Urd server.  Each request is assigned with an uniqe timestamp, and
stored in the requested list.

When Urd is restarted, it reads all the database files, and sorts all
rows in order of the receive timestamp.  Thereafter, each row is
applied in increasing time order to the internal, RAM-based database.
Due to the unique timestamping, the result is a deterministic replica
of the previous run.

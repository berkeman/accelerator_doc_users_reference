\label{chap:urd_basic}

Build scripts are used to instruct the Accelerator about which jobs to
build.  This chapter describes the basics of job building.  More
advanced features, using the \texttt{urd} server, is presented in
chapter~\ref{chap:urd}.


\section{Build Scripts}
\index{build scripts}
Build scripts are executed by the \texttt{automatarunner} executable.
A build script must contain the function \texttt{main}, since this is
called by the runner, like this
\index{build script!\texttt{main} function}
\begin{python}
def main(urd):
    ...
\end{python}
At run time, the \texttt{runner} inserts an object of the \texttt{Urd}
class as argument to the \texttt{main} function.  This \texttt{urd}
object has a number of member functions and attributes useful for job
building and tracking.  For tracking purposes, it remembers all jobs
that are built, together with their input parameters and some more
meta information.  This chapter will only cover the basic
possibilities provided by Urd, and a more comprehensive view will be
provided in the next chapter.



\subsection{Building a Job}
The \texttt{build} function is used to build a job from a method
(i.e.\ source file).  Here is an example of how to build the method
\texttt{method1}:
\begin{python}
def main(urd):
    urd.build('method1')
\end{python}
The full syntax for the \texttt{build} function is as follows
\index{\texttt{urd.build}}
\begin{python}
jobid = urd.build(method,
                  options={}, datasets={}, jobids={},
                  name='', caption='', workdir=None)
\end{python}
All paramters, except the name of the method, are optional, and
the \texttt{options}, \texttt{datasets}, and \texttt{jobids}
parameters must correspond to what is defined in the method to be
executed.  Urd will record the job based on the name of the method,
unless the \texttt{name=} is specified.  It is, for example, common to
build several \texttt{csvimport} jobs, and using \texttt{name=} they
can be told apart easily.  It is also possible to assign a caption to
a job, but this has no functional benefits.

When the job has been successfully built, the \texttt{build} function
will return a reference, a \textsl{jobid} to the job.  Similarly, if
the job already existed in an available \textsl{workdir}, the
\texttt{build} function immediately returns the jobid to that job
without executing anything.



\subsection{Connecting Jobs}
It is straightforward to connect jobs by feeding the output jobid from
the \texttt{build} function into a new job build.  For example
\begin{python}
jid_filter = urd.build('filter', datasets=dict(source=<some_input>))
jid_reduce = urd.build('reduce', datasets=dict(source=jid_filter))
\end{python}
In the example above, the first job, \texttt{filter}, creates a new
dataset from its input dataset.  This is then forwarded to the second
job, \texttt{reduce}, using the jobid reference \texttt{jid\_filter}.

If the first method or its input data is changed, the job will run
again.  This will cause the jobid \texttt{jid\_filter} to change too,
which in turn will trig execution of the \texttt{reduce} job.



\subsection{Building Chained Jobs}
It is also possible to build chained jobs implicitly using the
\texttt{build\_chained} function
\begin{python}
jobid = urd.build_chained('method1', name='myjob')
\end{python}
which takes the same options as the standard \texttt{build} method,
with the exception that name is mandatory.  The method to be chained
must have a ``\texttt{previous}'' key in its \texttt{datasets}
parameter.  The latest job with the same name is looked up by the
runner, and the corresponding jobid is assigned to the
method's \texttt{datasets.previous}.



\subsection{Replaying Build Scripts}
Executing an unmodified build script again will not cause any new jobs
to be executed.  Instead, the Accelerator will fill in the jobids of
the existing jobs so that processing can continue immediately.  A
successful ``replay'' of a build script ensures the integrity and
dependencies of the calculations.  If nothing has changed, the same
result remains.  If, however, some of the code has been modified, the
Accelerator will compute new jobs, the result may be different, and
the user is notified.




\section{The Joblist Type}
It has already been metioned that Urd keeps track of all built jobs.
This information is stored in the \texttt{urd.joblist} variable.  This
variable is of type \texttt{JobList}, which is basically
a \texttt{list} with some additional features.  The \texttt{joblist}
is an ordered list of jobs and it can be pretty-printed like this
\begin{python}
def main(urd):
    jid1 = urd.build('first')
    jid2 = urd.build('second', jobids=dict(first=jid1))
    print(urd.joblist.pretty)
\end{python}
which results in
\begin{shell}
JobList(
   [  0]  first : TEST-38
   [  1] second : TEST-39
)
\end{shell}
Any job in the list can be accessed by its name, so for example the
jobid to the \texttt{first} job could be retrieved by
\begin{python}
urd.joblist['first'].jobid
\end{python}
Using the joblist, we can modify our example to
\begin{python}
def main(urd):
    urd.build('first')
    urd.build('second', jobids=dict(first=urd.joblist['first'].jobid))
\end{python}
The ``\texttt{.jobid}'' is a bit clumsy, but currently required to get
the actual jobid for the job.  It is required because each item in
the \texttt{joblist} has a \texttt{.jobid} and a \texttt{.method}.
Note that if there are several jobs created by the same method, they
will have the same key in the joblist.  This situation could be
resolved using unique names to the \texttt{name=} option to
the \texttt{build()}-function as mentioned earlier.

An important special case is that the \textsl{latest} jobid is always
accessible using \texttt{urd.joblist.jobid}, so the code example could
also be written
\begin{python}
def main(urd):
    urd.build('first')
    urd.build('second', jobids=dict(first=urd.joblist.jobid))
\end{python}

It is also possible to look up jobs by name in the \texttt{joblist}.
This is done using the \texttt{find} function
\begin{python}
urd.joblist.find('csvimport')
\end{python}
If there is more than one job matching, the last one will be returned.

Finally, it may be worth noting that the \texttt{Joblist} is actually
a \texttt{list}, so it is possible to access individual items like
this
\begin{python}
jl[3]
\end{python}
and slicing works, too
\begin{python}
jl[-2:]
\end{python}


\section{Configuration Information from the Daemon}
The dictionary \texttt{urd.info} contains configuration information
from the Accelerator daemon.  In particular, it contains these fields
\starttabletwo
\RPtwo \texttt{slices} & Configured number of slices.\\[1ex]
\RPtwo \texttt{urd} & An URL to the Urd server, if configured,
  \pyNone otherwise.\\[1ex]
\RPtwo \texttt{result\_directory} & see section~\ref{}.\\[1ex]
\RPtwo \texttt{common\_directory} & see section~\ref{}.\\[1ex]
\RPtwo \texttt{source\_directory} & see section~\ref{}.\\[1ex]
\stoptabletwo



\section{Summary}
The \texttt{urd} object has functionality for building and retreiveing
jobs.  A job is built using \texttt{urd.build()}, and references to
all built jobs will be stored in \texttt{urd.joblist}.  These
references could be fed as input parameters to new jobs so that the
output from one job could be used by another.
The \texttt{urd.joblist} variable is basically of type \texttt{list},
but with extra functionality to find previous jobs and their jobids.
